<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Wiz Mapper: Loop & Overflow Fixed</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        body { background: #000; color: #0f0; display: flex; flex-direction: column; align-items: center; font-family: 'DotGothic16', sans-serif; margin: 0; padding: 20px; }

        .main-container {
            display: flex;
            gap: 10px; /* 20pxから10px（お好みで）に変更 */
            align-items: flex-start;
        }

        /* 1. キャンバスコンテナの背景を黒にする（念のため） */
        .canvas-container { 
            background: #000; /* #111 から #000 に変更 */
            width: fit-content;    /* これを追加：幅をキャンバスに合わせる */
            padding: 0;
            line-height: 0;
        }

        canvas {
            background: #000;
            image-rendering: pixelated;
            /* 十字カーソルを強制 */
            cursor: crosshair;
            /* 外枠（キャンバスの縁） */
            border: 1px solid #002200;
        }

        .help-panel { border: 1px solid #0f0; padding: 15px; width: 280px; background: #050505; font-size: 0.85em; line-height: 1.6; }
        .help-panel h3 { margin-top: 0; border-bottom: 1px solid #0f0; padding-bottom: 5px; color: #fff; }
        
        /* 2. ステータス欄の幅をキャンバスに合わせる */
        .status { 
            margin-bottom: 10px; 
            border: 2px solid #0f0; 
            padding: 10px; 
            width: 421px; /* 400px から 421px に変更 */
            box-sizing: border-box; /* 枠線を含めた計算にする */
            background: #000; 
        }


        .highlight { color: #fff; text-shadow: 0 0 5px #fff; }
        .key { color: #ff0; border: 1px solid #ff0; padding: 0 4px; border-radius: 3px; font-size: 0.8em; }
        button { background: #000; color: #0f0; border: 1px solid #0f0; cursor: pointer; font-family: 'DotGothic16'; padding: 5px 10px; }
        
        /* 3. テキストエリアの幅をキャンバスに合わせる（これが最重要！） */
        textarea { 
            width: 421px; /* 460px から 421px に変更 */
            box-sizing: border-box; 
            height: 40px; 
            background: #111; 
            color: #0a0; 
            border: 1px solid #333; 
            font-size: 10px; 
            margin-top: 10px; 
        }



    </style>
</head>
<body>
    <h1 style="text-shadow: 0 0 10px #0f0;">--- EXPERT MAPPER ---</h1>

    <div class="main-container">
        <div>
            <div class="status">
                <div id="pos">POS: X00, Y19 | DIR: NORTH</div>
                <div id="hoverPos" style="color: #888;">CURSOR: -</div>
                <div id="memoDisplay" style="color: #0ff;">FRONT: -</div>
            </div>

            <div class="canvas-container" style="overflow: visible;">
                <canvas id="mapCanvas" width="421" height="421" style="overflow: visible;"></canvas>
            </div>

            <div style="margin-top:10px; display:flex; gap:5px;">
                <button onclick="exportJSON()">JSON出力</button>
                <button onclick="importJSON()">JSON読込</button>
                <button onclick="saveAsImage()">PNG保存</button>
                <button onclick="fullReset()" style="color:#f00; border-color:#f00;">全消去</button>
            </div>
            <textarea id="jsonArea" placeholder="JSON DATA..."></textarea>
        </div>

        <div class="help-panel">
            <h3>[ 操作ガイド ]</h3>
            <strong>■ 移動 (WASD+QE)</strong><br>
            <span class="key">W</span> <span class="key">S</span> 前後 / <span class="key">Q</span> <span class="key">E</span> 平行<br>
            <span class="key">A</span> <span class="key">D</span> 旋回 / <span class="key">左Click</span> 移動<br>
            <br>
            <strong>■ 壁・扉 (正面に配置)</strong><br>
            <span class="key">Num 8,4,6,2</span> 相対壁<br>
            <span class="key">Num 5</span> 扉種類切替<br>
            <small>(壁→扉→隠し→一方通行→消去)</small><br>
            <br>
            <strong>■ 特殊タイル (足元に配置)</strong><br>
            <span class="key">↑↓←→</span> [上階][下階][罠][回転床]<br>
            <span class="key">0</span> ダークゾーン(ON/OFF)<br>
            <span class="key">M</span> <span class="highlight">詳細メモ・メッセージ入力</span><br>
            <br>
            <strong>■ 特殊機能</strong><br>
            <span class="key">Shift + Click</span> ワープ線(2点選ぶ)<br>
            <span class="key">Shift + ↑↓←→</span> マップ全体をずらす<br>
            <span class="key">L</span> ワープ線を全消去 / <span class="key">C</span> 足元のメモ消去
        </div>



    <script>

const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 20;
        const offset = 10; // 矢印のはみ出しを許容する最小限の余白
        const DX = [0, 1, 0, -1], DY = [-1, 0, 1, 0];

        let player = { x: 0, y: 19, dir: 0 }; 
        let visited = Array.from({ length: 20 }, () => Array(20).fill(false));
        let wallMap = Array.from({ length: 20 }, () => Array.from({ length: 20 }, () => Array(4).fill(0)));
        let memoMap = Array.from({ length: 20 }, () => Array(20).fill(""));
        let darkMap = Array.from({ length: 20 }, () => Array(20).fill(false));
        let links = [];
        let linkStart = null;

        function saveData() { localStorage.setItem('wiz_map_v7', JSON.stringify({ player, visited, wallMap, memoMap, darkMap, links })); }
        function loadData() {
            const saved = localStorage.getItem('wiz_map_v7');
            if (saved) {
                const p = JSON.parse(saved);
                player = p.player; visited = p.visited; wallMap = p.wallMap; 
                memoMap = p.memoMap; darkMap = p.darkMap; links = p.links || [];
            }
        }

        function drawWall(x, y, d, type) {
            renderWallSymbol(x, y, d, type);
            // ループ回り込み描画
            if (x === 0) renderWallSymbol(x + 20, y, d, type);
            if (x === 19) renderWallSymbol(x - 20, y, d, type);
            if (y === 0) renderWallSymbol(x, y + 20, d, type);
            if (y === 19) renderWallSymbol(x, y - 20, d, type);
            if (x === 0 && y === 0) renderWallSymbol(20, 20, d, type);
            if (x === 19 && y === 0) renderWallSymbol(-1, 20, d, type);
            if (x === 0 && y === 19) renderWallSymbol(20, -1, d, type);
            if (x === 19 && y === 19) renderWallSymbol(-1, -1, d, type);
        }

        function renderWallSymbol(gx, gy, dir, type) {
            ctx.save();
            ctx.translate(gx * cellSize, gy * cellSize);
            if(dir === 1) { ctx.translate(cellSize, 0); ctx.rotate(Math.PI / 2); }
            if(dir === 2) { ctx.translate(cellSize, cellSize); ctx.rotate(Math.PI); }
            if(dir === 3) { ctx.translate(0, cellSize); ctx.rotate(Math.PI * 1.5); }
            ctx.strokeStyle = "#0f0"; ctx.fillStyle = "#0f0"; ctx.lineWidth = 2;
            if (type === 1) { ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(cellSize,0); ctx.stroke(); }
            else if (type === 2) { 
                ctx.beginPath(); ctx.moveTo(2, -2.5); ctx.lineTo(cellSize-2, -2.5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(2, 2.5); ctx.lineTo(cellSize-2, 2.5); ctx.stroke();
            }
            else if (type === 4) {
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(cellSize,0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cellSize/2, 6); ctx.lineTo(cellSize/2, -5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cellSize/2-4,-4); ctx.lineTo(cellSize/2+4,-4); ctx.lineTo(cellSize/2,-11); ctx.closePath(); ctx.fill();
            }
            ctx.restore();
        }

        function updateStatus() {
            document.getElementById('pos').innerText = `POS: X${player.x}, Y${19-player.y} | DIR: ${["NORTH","EAST","SOUTH","WEST"][player.dir]}`;
            const fx = player.x + DX[player.dir], fy = player.y + DY[player.dir];
            const fMemo = (fx>=0 && fx<20 && fy>=0 && fy<20) ? memoMap[fx][fy] : "OUT";
            document.getElementById('memoDisplay').innerText = `FRONT: ${fMemo || "-"}`;
        }


        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            // 全体を10px右下にずらす（これで上下左右10pxずつの余白が完成）
            ctx.translate(offset, offset); 

            // 1. グリッドと外枠
            // ctx.strokeStyle = "#001500"; ctx.lineWidth = 1;
            for(let i=0; i<=20; i++){
                // 0番目と20番目（一番外側）は少しだけ明るくして「境界」であることを示す
                ctx.strokeStyle = (i === 0 || i === 20) ? "#004400" : "#001500";
                ctx.lineWidth = 1;
                
                // 縦線
                ctx.beginPath(); ctx.moveTo(i*cellSize, 0); ctx.lineTo(i*cellSize, 400); ctx.stroke();
                // 横線
                ctx.beginPath(); ctx.moveTo(0, i*cellSize); ctx.lineTo(400, i*cellSize); ctx.stroke();
            }



            // 床・ダークゾーン
            for(let x=0; x<20; x++) {
                for(let y=0; y<20; y++) {
                    if(darkMap[x][y]) {
                        ctx.fillStyle = "#000"; ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
                        ctx.save(); ctx.beginPath(); ctx.rect(x*cellSize, y*cellSize, cellSize, cellSize); ctx.clip();
                        ctx.strokeStyle = "#666"; ctx.lineWidth = 1;
                        for(let o=-cellSize; o<=cellSize*2; o+=6){ ctx.moveTo(x*cellSize+o, y*cellSize); ctx.lineTo(x*cellSize+o+cellSize, y*cellSize+cellSize); }
                        ctx.stroke(); ctx.restore();
                    } else if(visited[x][y]) {
                        ctx.fillStyle = "#001a00"; ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
                    }
                    const text = memoMap[x][y];
                    if(text) {
                        ctx.font = "bold 11px 'DotGothic16'"; ctx.textAlign = "center";
                        ctx.fillStyle = (text==="罠")?"#f33":(text==="転")?"#f3f":"#3ff";
                        ctx.fillText((text==="上")?"U":(text==="下")?"D":text.substring(0,1), x*cellSize+10, y*cellSize+14);
                    }
                }
            }

            // ワープ線 (復活)
            ctx.save(); ctx.strokeStyle = "rgba(255, 255, 0, 0.5)"; ctx.setLineDash([4, 2]);
            links.forEach(l => {
                ctx.beginPath(); ctx.moveTo(l.fx*20+10, l.fy*20+10); ctx.lineTo(l.tx*20+10, l.ty*20+10); ctx.stroke();
                ctx.fillStyle = "#ff0"; ctx.setLineDash([]); ctx.beginPath(); ctx.arc(l.tx*20+10, l.ty*20+10, 2, 0, 7); ctx.fill();
            }); ctx.restore();

            // 壁
            for(let x=0; x<20; x++) for(let y=0; y<20; y++) for(let d=0; d<4; d++) if(wallMap[x][y][d]) drawWall(x, y, d, wallMap[x][y][d]);

            // プレイヤー
            ctx.save(); ctx.translate(player.x*cellSize+10, player.y*cellSize+10); ctx.rotate((player.dir*90)*Math.PI/180);
            ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(5,5); ctx.lineTo(-5,5); ctx.closePath(); ctx.fill();
            ctx.restore();
            ctx.restore();
            updateStatus();
        }

        function setWall(x, y, d, type) {
            const targetType = (wallMap[x][y][d] === type) ? 0 : type;
            wallMap[x][y][d] = targetType;
            const nx = (x + DX[d] + 20) % 20, ny = (y + DY[d] + 20) % 20;
            if (targetType === 4) wallMap[nx][ny][(d + 2) % 4] = 0;
            else wallMap[nx][ny][(d + 2) % 4] = targetType;
            draw(); saveData();
        }

        window.addEventListener('keydown', (e) => {
            const k = e.key, wk = k.toLowerCase();
            if(wk === "m") {
                const v = prompt("MEMO:", memoMap[player.x][player.y]);
                if(v !== null) { memoMap[player.x][player.y] = v; draw(); saveData(); }
                return;
            }
            if(["w","s","q","e","a","d"].includes(wk)){
                let nx = player.x, ny = player.y;
                if(wk==="w"){ nx+=DX[player.dir]; ny+=DY[player.dir]; }
                if(wk==="s"){ nx-=DX[player.dir]; ny-=DY[player.dir]; }
                if(wk==="q"){ let qd=(player.dir+3)%4; nx+=DX[qd]; ny+=DY[qd]; }
                if(wk==="e"){ let ed=(player.dir+1)%4; nx+=DX[ed]; ny+=DY[ed]; }
                if(wk==="a") player.dir=(player.dir+3)%4;
                if(wk==="d") player.dir=(player.dir+1)%4;
                player.x=(nx+20)%20; player.y=(ny+20)%20;
                visited[player.x][player.y]=true; draw(); saveData();
            }
            if(wk==="8") setWall(player.x, player.y, player.dir, 1);
            if(wk==="4") setWall(player.x, player.y, (player.dir+3)%4, 1);
            if(wk==="6") setWall(player.x, player.y, (player.dir+1)%4, 1);
            if(wk==="2") setWall(player.x, player.y, (player.dir+2)%4, 1);
            if(wk==="5") setWall(player.x, player.y, player.dir, (wallMap[player.x][player.y][player.dir]+1)%5);
            if(k==="0"){ darkMap[player.x][player.y]=!darkMap[player.x][player.y]; draw(); saveData(); }


            // 足元のメモ（上/下/罠/転および詳細メモ）を消去
            if (wk === "c") {
                memoMap[player.x][player.y] = "";
                draw();
                saveData();
                return; // 処理終了
            }


            if(k.startsWith("Arrow") && !e.shiftKey){
                let m = (k==="ArrowUp")?"上":(k==="ArrowDown")?"下":(k==="ArrowLeft")?"罠":"転";
                memoMap[player.x][player.y] = (memoMap[player.x][player.y]===m)?"":m;
                draw(); saveData();
            }
            if(wk==="l"){ if(confirm("Clear Lines?")){links=[]; draw(); saveData();} }
            if(e.shiftKey && k.startsWith("Arrow")) {
                const sx = (k === "ArrowLeft") ? -1 : (k === "ArrowRight") ? 1 : 0;
                const sy = (k === "ArrowUp") ? -1 : (k === "ArrowDown") ? 1 : 0;
                const oldW=JSON.parse(JSON.stringify(wallMap)), oldM=JSON.parse(JSON.stringify(memoMap)), oldV=JSON.parse(JSON.stringify(visited)), oldD=JSON.parse(JSON.stringify(darkMap));
                for(let x=0; x<20; x++) for(let y=0; y<20; y++) {
                    let nx=(x+sx+20)%20, ny=(y+sy+20)%20;
                    wallMap[nx][ny]=oldW[x][y]; memoMap[nx][ny]=oldM[x][y]; visited[nx][ny]=oldV[x][y]; darkMap[nx][ny]=oldD[x][y];
                }
                player.x=(player.x+sx+20)%20; player.y=(player.y+sy+20)%20;
                draw(); saveData();
            }
        });


        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const gx = Math.floor((e.clientX - rect.left - offset) / cellSize);
            const gy = Math.floor((e.clientY - rect.top - offset) / cellSize);

            // 20マスの範囲内にいるか判定
            if (gx >= 0 && gx < 20 && gy >= 0 && gy < 20) {
                canvas.style.cursor = 'crosshair'; // 範囲内は十字
                document.getElementById('hoverPos').innerText = `CURSOR: X${gx}, Y${19 - gy} ${memoMap[gx][gy] ? '[' + memoMap[gx][gy] + ']' : ''}`;
            } else {
                canvas.style.cursor = 'default'; // 範囲外は矢印
                document.getElementById('hoverPos').innerText = `CURSOR: OUTSIDE`;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            // マウス座標から、キャンバスの枠と「10pxの余白」を引いて計算
            const gx = Math.floor((e.clientX - rect.left - offset) / cellSize);
            const gy = Math.floor((e.clientY - rect.top - offset) / cellSize);

            if (gx >= 0 && gx < 20 && gy >= 0 && gy < 20) {
                if (e.shiftKey) {
                    // Shift+クリックでワープ線作成
                    if (!linkStart) {
                        linkStart = { fx: gx, fy: gy };
                    } else {
                        // 同じ場所でなければリンクを追加
                        if (linkStart.fx !== gx || linkStart.fy !== gy) {
                            links.push({ ...linkStart, tx: gx, ty: gy });
                        }
                        linkStart = null;
                    }
                } else {
                    // 通常クリックで移動
                    player.x = gx;
                    player.y = gy;
                    visited[gx][gy] = true;
                }
                draw();
                saveData();
            }
        });


        function exportJSON() { document.getElementById('jsonArea').value = JSON.stringify({wallMap, memoMap, visited, darkMap, links}); }
        
        function importJSON() {
            try {
                const area = document.getElementById('jsonArea');
                if (!area.value) return;

                const p = JSON.parse(area.value);

                // 各データを安全に流し込む（データがない場合は現在の値を維持）
                if (p.wallMap) wallMap = p.wallMap;
                if (p.memoMap) memoMap = p.memoMap;
                if (p.visited) visited = p.visited;
                if (p.darkMap) darkMap = p.darkMap;
                if (p.links)   links   = p.links;
                if (p.player)  player  = p.player;

                // 描画して保存
                draw(); 
                saveData();

                // 成功時のみ通知（これまでの "Error" 表示を削除）
                console.log("JSON Import Success");
                alert("マップデータを読み込みました。");

            } catch (e) {
                // エラー時はコンソールに詳細を出しつつ、ユーザーに通知
                console.error("Import Error Detail:", e);
                alert("読み込みに失敗しました。JSONの形式を確認してください。\nエラー内容: " + e.message);
            }
        }        

        function saveAsImage() { const link = document.createElement('a'); link.download = 'wiz_map.png'; link.href = canvas.toDataURL(); link.click(); }
        function fullReset() { if(confirm("RESET ALL?")) { localStorage.clear(); location.reload(); } }

        loadData(); visited[player.x][player.y]=true; draw();
    </script>
</body>
</html>